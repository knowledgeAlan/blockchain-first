{
    "sourceFile": "src/blockchain.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 13,
            "patches": [
                {
                    "date": 1690771313153,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1690771338900,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -39,8 +39,10 @@\n             let errors = await self.validateChain();\n             \n             console.log(\"errors: \" + errors);\n \n+            console.log(\"validation of chain ends\");\n+\n             \n \n         });\n     }\n"
                },
                {
                    "date": 1690771362683,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -41,10 +41,15 @@\n             console.log(\"errors: \" + errors);\n \n             console.log(\"validation of chain ends\");\n \n-            \n \n+            if(errors.length === 0){\n+\n+            }else{\n+                reject(errors);\n+            }\n+\n         });\n     }\n \n     requestMessageOwnnershipVerification(address){\n"
                },
                {
                    "date": 1690771390071,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -44,8 +44,11 @@\n \n \n             if(errors.length === 0){\n \n+                self.chain.push(block);\n+                self.height++;\n+                resolve(block);\n             }else{\n                 reject(errors);\n             }\n \n"
                },
                {
                    "date": 1690858389327,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -26,9 +26,9 @@\n         let self = this;\n         return new Promise(async(resolve, reject) =>{\n \n             block.height = self.chain.length;\n-            block.time = new Date().getTime().slice(0,-3);\n+            block.time = new Date().getTime().toString().slice(0,-3);\n             if(self.chain.length > 0){\n                 block.previousBlockHash = self.chain[self.chain.length -1].hash;\n             }\n \n@@ -57,23 +57,46 @@\n \n     requestMessageOwnnershipVerification(address){\n         return new Promise((resolve)=>{\n \n+            let date = new Date().getTime().toString().slice(0,-3);\n+            const ownerShipMessage = `${address}:${date}:starRegistry`;\n+            resolve(ownerShipMessage);\n         });\n     }\n \n     submitStart(address,message,signature,star){\n         let self = this;\n         return new Promise(async (resolve, reject)=>{\n+            \n+            let temps = parseInt(message.split(\":\")[1]);\n+            let currentTime = parseInt(new Date().getTime().toString().slice(0,-3));\n \n+            if(currentTime - temps < (5*60)){\n+                if(bitcoinMessge.verify(message,address,signature)){\n+                    let block = new BlockClass.Block({\"owner\":address,\"star\":star});\n+                    self._addBlock(block);\n+                }else{\n+                    reject(Error(\"Message is not verified\"))\n+                }\n+            }else{\n+                reject(Error(\"too much time has passed ,stay below 5 minutes\"));\n+            }\n         });\n     }\n \n \n     getBlockByHash(hash){\n         let self = this;\n         return new Promise((resolve,reject)=>{\n \n+            const block = self.chain.filter(block => block.hash === hash);\n+\n+            if(type block != \"undefined\"){\n+                resolve(block);\n+            }else{\n+                reject(Error(\"No block with hash\"));\n+            }\n         })\n     }\n \n \n@@ -96,8 +119,19 @@\n         let self = this;\n         let stars = [];\n         return new Promise((resolve,reject)=>{\n \n+            self.chain.forEach(async(b) =>{\n+                let data = await b.getData();\n+\n+                if(data){\n+                    if(data.owner === address){\n+                        stars.push(data);\n+                    }\n+                }\n+            })\n+\n+            resolve(stars);\n         });\n     }\n \n \n@@ -105,9 +139,38 @@\n         let self = this;\n         let errorLog = [];\n         return new Promise(async (resolve,reject)=>{\n \n+\n+            let validatePromoises = [];\n+\n+            self.chain.forEach((block,index) = >{\n+                if(block.height > 0){\n+                    const previousBlock = self.chain[indiex - 1];\n+                    if(block.previousBlockHash !== previousBlock.hash){\n+                        const errorMessage = `Block ${index} previousBlockHash set to ${block.previousBlcokHash},but actual previous block hash was ${previousBlock.hash}`;\n+                        errorLog.push(errorMessage);\n+                    }\n+                }\n+\n+                validatePromises.push(block.validate());\n+            });\n+\n+            Promises.all(validatePromises)\n+                    .then(validatedBlocks =>{\n+                        validatedBlocks.forEach((valid,index) =>{\n+\n+                            if(!valid){\n+                                const invalidBlock = self.chain[index];\n+                                const errorMessage = `Block ${index} hash (${invalidBlock.hash}) is invalid`;\n+                                errorLog.push(errorMessage);\n+                            }\n+                        })\n+\n+                        resolve(errorLog);\n+                    });\n         });\n+\n     }\n }\n \n module.exports.Blockchain = Blockchain;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1690858405568,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -90,9 +90,9 @@\n         return new Promise((resolve,reject)=>{\n \n             const block = self.chain.filter(block => block.hash === hash);\n \n-            if(type block != \"undefined\"){\n+            if(typeof block != \"undefined\"){\n                 resolve(block);\n             }else{\n                 reject(Error(\"No block with hash\"));\n             }\n"
                },
                {
                    "date": 1690858414758,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -142,9 +142,9 @@\n \n \n             let validatePromoises = [];\n \n-            self.chain.forEach((block,index) = >{\n+            self.chain.forEach((block,index) =>{\n                 if(block.height > 0){\n                     const previousBlock = self.chain[indiex - 1];\n                     if(block.previousBlockHash !== previousBlock.hash){\n                         const errorMessage = `Block ${index} previousBlockHash set to ${block.previousBlcokHash},but actual previous block hash was ${previousBlock.hash}`;\n"
                },
                {
                    "date": 1690858638890,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -154,9 +154,9 @@\n \n                 validatePromises.push(block.validate());\n             });\n \n-            Promises.all(validatePromises)\n+            Promises.all(validatePromoises)\n                     .then(validatedBlocks =>{\n                         validatedBlocks.forEach((valid,index) =>{\n \n                             if(!valid){\n"
                },
                {
                    "date": 1690858650641,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -154,9 +154,9 @@\n \n                 validatePromises.push(block.validate());\n             });\n \n-            Promises.all(validatePromoises)\n+            Promise.all(validatePromoises)\n                     .then(validatedBlocks =>{\n                         validatedBlocks.forEach((valid,index) =>{\n \n                             if(!valid){\n"
                },
                {
                    "date": 1690859507610,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -54,9 +54,9 @@\n \n         });\n     }\n \n-    requestMessageOwnnershipVerification(address){\n+    requestMessageOwnershipVerification(address){\n         return new Promise((resolve)=>{\n \n             let date = new Date().getTime().toString().slice(0,-3);\n             const ownerShipMessage = `${address}:${date}:starRegistry`;\n@@ -151,9 +151,9 @@\n                         errorLog.push(errorMessage);\n                     }\n                 }\n \n-                validatePromises.push(block.validate());\n+                validatePromoises.push(block.validate());\n             });\n \n             Promise.all(validatePromoises)\n                     .then(validatedBlocks =>{\n"
                },
                {
                    "date": 1690859565297,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,176 @@\n+const SHA256 = require('crypto-js/sha256');\n+const BlockClass = require('./block');\n+\n+class Blockchain {\n+\n+    constructor(){\n+        this.chain = [];\n+        this.height = -1;\n+        this.initializeChain();\n+    }\n+\n+    async initializeChain(){\n+        if(this.height === -1){\n+            let block = new BlockClass.Block({data:\"Gensis Block\"});\n+            await this._addBlock(block);\n+        }\n+    }\n+\n+    getChainHeight(){\n+        return new Promise((resolve, reject) =>{\n+            resolve(this.height);\n+        });\n+    }\n+\n+    _addBlock(block) {\n+        let self = this;\n+        return new Promise(async(resolve, reject) =>{\n+\n+            block.height = self.chain.length;\n+            block.time = new Date().getTime().toString().slice(0,-3);\n+            if(self.chain.length > 0){\n+                block.previousBlockHash = self.chain[self.chain.length -1].hash;\n+            }\n+\n+            block.hash = SHA256(JSON.stringify(block)).toString();\n+            console.log(\"validation of chain starts here\");\n+\n+\n+            let errors = await self.validateChain();\n+            \n+            console.log(\"errors: \" + errors);\n+\n+            console.log(\"validation of chain ends\");\n+\n+\n+            if(errors.length === 0){\n+\n+                self.chain.push(block);\n+                self.height++;\n+                resolve(block);\n+            }else{\n+                reject(errors);\n+            }\n+\n+        });\n+    }\n+\n+    requestMessageOwnershipVerification(address){\n+        return new Promise((resolve)=>{\n+\n+            let date = new Date().getTime().toString().slice(0,-3);\n+            const ownerShipMessage = `${address}:${date}:starRegistry`;\n+            resolve(ownerShipMessage);\n+        });\n+    }\n+\n+    submitStar(address,message,signature,star){\n+        let self = this;\n+        return new Promise(async (resolve, reject)=>{\n+            \n+            let temps = parseInt(message.split(\":\")[1]);\n+            let currentTime = parseInt(new Date().getTime().toString().slice(0,-3));\n+\n+            if(currentTime - temps < (5*60)){\n+                if(bitcoinMessge.verify(message,address,signature)){\n+                    let block = new BlockClass.Block({\"owner\":address,\"star\":star});\n+                    self._addBlock(block);\n+                }else{\n+                    reject(Error(\"Message is not verified\"))\n+                }\n+            }else{\n+                reject(Error(\"too much time has passed ,stay below 5 minutes\"));\n+            }\n+        });\n+    }\n+\n+\n+    getBlockByHash(hash){\n+        let self = this;\n+        return new Promise((resolve,reject)=>{\n+\n+            const block = self.chain.filter(block => block.hash === hash);\n+\n+            if(typeof block != \"undefined\"){\n+                resolve(block);\n+            }else{\n+                reject(Error(\"No block with hash\"));\n+            }\n+        })\n+    }\n+\n+\n+    getBlockByHeight(height){\n+        let self = this;\n+\n+        return new Promise((resolve,reject)=>{\n+            let block = self.chain.filter(p=> p.height=== height)[0];\n+\n+            if(block){\n+                resolve(block);\n+            }else{\n+                resolve(null);\n+            }\n+        });\n+    }\n+\n+\n+    getStarsByWalletAddress(address){\n+        let self = this;\n+        let stars = [];\n+        return new Promise((resolve,reject)=>{\n+\n+            self.chain.forEach(async(b) =>{\n+                let data = await b.getData();\n+\n+                if(data){\n+                    if(data.owner === address){\n+                        stars.push(data);\n+                    }\n+                }\n+            })\n+\n+            resolve(stars);\n+        });\n+    }\n+\n+\n+    validateChain(){\n+        let self = this;\n+        let errorLog = [];\n+        return new Promise(async (resolve,reject)=>{\n+\n+\n+            let validatePromoises = [];\n+\n+            self.chain.forEach((block,index) =>{\n+                if(block.height > 0){\n+                    const previousBlock = self.chain[indiex - 1];\n+                    if(block.previousBlockHash !== previousBlock.hash){\n+                        const errorMessage = `Block ${index} previousBlockHash set to ${block.previousBlcokHash},but actual previous block hash was ${previousBlock.hash}`;\n+                        errorLog.push(errorMessage);\n+                    }\n+                }\n+\n+                validatePromoises.push(block.validate());\n+            });\n+\n+            Promise.all(validatePromoises)\n+                    .then(validatedBlocks =>{\n+                        validatedBlocks.forEach((valid,index) =>{\n+\n+                            if(!valid){\n+                                const invalidBlock = self.chain[index];\n+                                const errorMessage = `Block ${index} hash (${invalidBlock.hash}) is invalid`;\n+                                errorLog.push(errorMessage);\n+                            }\n+                        })\n+\n+                        resolve(errorLog);\n+                    });\n+        });\n+\n+    }\n+}\n+\n+module.exports.Blockchain = Blockchain;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1690859707303,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -144,9 +144,9 @@\n             let validatePromoises = [];\n \n             self.chain.forEach((block,index) =>{\n                 if(block.height > 0){\n-                    const previousBlock = self.chain[indiex - 1];\n+                    const previousBlock = self.chain[index - 1];\n                     if(block.previousBlockHash !== previousBlock.hash){\n                         const errorMessage = `Block ${index} previousBlockHash set to ${block.previousBlcokHash},but actual previous block hash was ${previousBlock.hash}`;\n                         errorLog.push(errorMessage);\n                     }\n@@ -172,181 +172,5 @@\n \n     }\n }\n \n-module.exports.Blockchain = Blockchain;\n-const SHA256 = require('crypto-js/sha256');\n-const BlockClass = require('./block');\n-\n-class Blockchain {\n-\n-    constructor(){\n-        this.chain = [];\n-        this.height = -1;\n-        this.initializeChain();\n-    }\n-\n-    async initializeChain(){\n-        if(this.height === -1){\n-            let block = new BlockClass.Block({data:\"Gensis Block\"});\n-            await this._addBlock(block);\n-        }\n-    }\n-\n-    getChainHeight(){\n-        return new Promise((resolve, reject) =>{\n-            resolve(this.height);\n-        });\n-    }\n-\n-    _addBlock(block) {\n-        let self = this;\n-        return new Promise(async(resolve, reject) =>{\n-\n-            block.height = self.chain.length;\n-            block.time = new Date().getTime().toString().slice(0,-3);\n-            if(self.chain.length > 0){\n-                block.previousBlockHash = self.chain[self.chain.length -1].hash;\n-            }\n-\n-            block.hash = SHA256(JSON.stringify(block)).toString();\n-            console.log(\"validation of chain starts here\");\n-\n-\n-            let errors = await self.validateChain();\n-            \n-            console.log(\"errors: \" + errors);\n-\n-            console.log(\"validation of chain ends\");\n-\n-\n-            if(errors.length === 0){\n-\n-                self.chain.push(block);\n-                self.height++;\n-                resolve(block);\n-            }else{\n-                reject(errors);\n-            }\n-\n-        });\n-    }\n-\n-    requestMessageOwnershipVerification(address){\n-        return new Promise((resolve)=>{\n-\n-            let date = new Date().getTime().toString().slice(0,-3);\n-            const ownerShipMessage = `${address}:${date}:starRegistry`;\n-            resolve(ownerShipMessage);\n-        });\n-    }\n-\n-    submitStart(address,message,signature,star){\n-        let self = this;\n-        return new Promise(async (resolve, reject)=>{\n-            \n-            let temps = parseInt(message.split(\":\")[1]);\n-            let currentTime = parseInt(new Date().getTime().toString().slice(0,-3));\n-\n-            if(currentTime - temps < (5*60)){\n-                if(bitcoinMessge.verify(message,address,signature)){\n-                    let block = new BlockClass.Block({\"owner\":address,\"star\":star});\n-                    self._addBlock(block);\n-                }else{\n-                    reject(Error(\"Message is not verified\"))\n-                }\n-            }else{\n-                reject(Error(\"too much time has passed ,stay below 5 minutes\"));\n-            }\n-        });\n-    }\n-\n-\n-    getBlockByHash(hash){\n-        let self = this;\n-        return new Promise((resolve,reject)=>{\n-\n-            const block = self.chain.filter(block => block.hash === hash);\n-\n-            if(typeof block != \"undefined\"){\n-                resolve(block);\n-            }else{\n-                reject(Error(\"No block with hash\"));\n-            }\n-        })\n-    }\n-\n-\n-    getBlockByHeight(height){\n-        let self = this;\n-\n-        return new Promise((resolve,reject)=>{\n-            let block = self.chain.filter(p=> p.height=== height)[0];\n-\n-            if(block){\n-                resolve(block);\n-            }else{\n-                resolve(null);\n-            }\n-        });\n-    }\n-\n-\n-    getStarsByWalletAddress(address){\n-        let self = this;\n-        let stars = [];\n-        return new Promise((resolve,reject)=>{\n-\n-            self.chain.forEach(async(b) =>{\n-                let data = await b.getData();\n-\n-                if(data){\n-                    if(data.owner === address){\n-                        stars.push(data);\n-                    }\n-                }\n-            })\n-\n-            resolve(stars);\n-        });\n-    }\n-\n-\n-    validateChain(){\n-        let self = this;\n-        let errorLog = [];\n-        return new Promise(async (resolve,reject)=>{\n-\n-\n-            let validatePromoises = [];\n-\n-            self.chain.forEach((block,index) =>{\n-                if(block.height > 0){\n-                    const previousBlock = self.chain[indiex - 1];\n-                    if(block.previousBlockHash !== previousBlock.hash){\n-                        const errorMessage = `Block ${index} previousBlockHash set to ${block.previousBlcokHash},but actual previous block hash was ${previousBlock.hash}`;\n-                        errorLog.push(errorMessage);\n-                    }\n-                }\n-\n-                validatePromoises.push(block.validate());\n-            });\n-\n-            Promise.all(validatePromoises)\n-                    .then(validatedBlocks =>{\n-                        validatedBlocks.forEach((valid,index) =>{\n-\n-                            if(!valid){\n-                                const invalidBlock = self.chain[index];\n-                                const errorMessage = `Block ${index} hash (${invalidBlock.hash}) is invalid`;\n-                                errorLog.push(errorMessage);\n-                            }\n-                        })\n-\n-                        resolve(errorLog);\n-                    });\n-        });\n-\n-    }\n-}\n-\n module.exports.Blockchain = Blockchain;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1690868899950,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,7 @@\n const SHA256 = require('crypto-js/sha256');\n const BlockClass = require('./block');\n-\n+const bitcoinMessage = require('bitcoinjs-message');\n class Blockchain {\n \n     constructor(){\n         this.chain = [];\n"
                },
                {
                    "date": 1690868933526,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -71,9 +71,9 @@\n             let temps = parseInt(message.split(\":\")[1]);\n             let currentTime = parseInt(new Date().getTime().toString().slice(0,-3));\n \n             if(currentTime - temps < (5*60)){\n-                if(bitcoinMessge.verify(message,address,signature)){\n+                if(bitcoinMessage.verify(message,address,signature)){\n                     let block = new BlockClass.Block({\"owner\":address,\"star\":star});\n                     self._addBlock(block);\n                 }else{\n                     reject(Error(\"Message is not verified\"))\n"
                }
            ],
            "date": 1690771313153,
            "name": "Commit-0",
            "content": "const SHA256 = require('crypto-js/sha256');\nconst BlockClass = require('./block');\n\nclass Blockchain {\n\n    constructor(){\n        this.chain = [];\n        this.height = -1;\n        this.initializeChain();\n    }\n\n    async initializeChain(){\n        if(this.height === -1){\n            let block = new BlockClass.Block({data:\"Gensis Block\"});\n            await this._addBlock(block);\n        }\n    }\n\n    getChainHeight(){\n        return new Promise((resolve, reject) =>{\n            resolve(this.height);\n        });\n    }\n\n    _addBlock(block) {\n        let self = this;\n        return new Promise(async(resolve, reject) =>{\n\n            block.height = self.chain.length;\n            block.time = new Date().getTime().slice(0,-3);\n            if(self.chain.length > 0){\n                block.previousBlockHash = self.chain[self.chain.length -1].hash;\n            }\n\n            block.hash = SHA256(JSON.stringify(block)).toString();\n            console.log(\"validation of chain starts here\");\n\n\n            let errors = await self.validateChain();\n            \n            console.log(\"errors: \" + errors);\n\n            \n\n        });\n    }\n\n    requestMessageOwnnershipVerification(address){\n        return new Promise((resolve)=>{\n\n        });\n    }\n\n    submitStart(address,message,signature,star){\n        let self = this;\n        return new Promise(async (resolve, reject)=>{\n\n        });\n    }\n\n\n    getBlockByHash(hash){\n        let self = this;\n        return new Promise((resolve,reject)=>{\n\n        })\n    }\n\n\n    getBlockByHeight(height){\n        let self = this;\n\n        return new Promise((resolve,reject)=>{\n            let block = self.chain.filter(p=> p.height=== height)[0];\n\n            if(block){\n                resolve(block);\n            }else{\n                resolve(null);\n            }\n        });\n    }\n\n\n    getStarsByWalletAddress(address){\n        let self = this;\n        let stars = [];\n        return new Promise((resolve,reject)=>{\n\n        });\n    }\n\n\n    validateChain(){\n        let self = this;\n        let errorLog = [];\n        return new Promise(async (resolve,reject)=>{\n\n        });\n    }\n}\n\nmodule.exports.Blockchain = Blockchain;"
        }
    ]
}